const mongoose = require('mongoose');

const questionSchema = new mongoose.Schema({
  // Basic Information
  title: {
    type: String,
    required: [true, 'Question title is required'],
    trim: true
  },
  type: {
    type: String,
    enum: ['mcq', 'cq', 'true_false', 'fill_blank'],
    required: [true, 'Question type is required']
  },
  
  // Academic Context
  subject: {
    type: String,
    required: [true, 'Subject is required'],
    trim: true
  },
  chapter: {
    type: String,
    required: [true, 'Chapter is required'],
    trim: true
  },
  topic: {
    type: String,
    trim: true
  },
  class: {
    type: Number,
    required: [true, 'Class is required'],
    min: [1, 'Class must be between 1-12'],
    max: [12, 'Class must be between 1-12']
  },
  
  // Difficulty & Metadata
  difficulty: {
    type: String,
    enum: ['easy', 'medium', 'hard'],
    required: [true, 'Difficulty level is required']
  },
  marks: {
    type: Number,
    required: [true, 'Marks is required'],
    min: [1, 'Marks must be at least 1']
  },
  timeLimit: {
    type: Number, // Time in minutes
    default: 2
  },
  
  // Question Content
  question: {
    text: {
      type: String,
      required: [true, 'Question text is required']
    },
    image: String, // URL to question image
    latex: String  // For mathematical expressions
  },
  
  // MCQ Specific Fields
  options: [{
    text: {
      type: String,
      required: function() {
        return this.type === 'mcq';
      }
    },
    image: String, // URL to option image
    isCorrect: {
      type: Boolean,
      default: false
    }
  }],
  
  // Correct Answer (for different question types)
  correctAnswer: {
    text: String,
    explanation: String,
    image: String, // URL to answer explanation image
    keyPoints: [String] // Key points for CQ answers
  },
  
  // Creator Information
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Creator is required']
  },
  source: {
    type: String,
    enum: ['manual', 'ai_generated', 'imported'],
    default: 'manual'
  },
  aiPrompt: String, // Store AI prompt if generated by AI
  
  // Usage Statistics
  usageStats: {
    totalAttempts: {
      type: Number,
      default: 0
    },
    correctAttempts: {
      type: Number,
      default: 0
    },
    averageTime: {
      type: Number,
      default: 0
    }
  },
  
  // Tags and Keywords
  tags: [String],
  keywords: [String],
  
  // Status
  isActive: {
    type: Boolean,
    default: true
  },
  isPublic: {
    type: Boolean,
    default: false // Teachers can make questions public for sharing
  },
  
  // Review and Quality
  reviewStatus: {
    type: String,
    enum: ['pending', 'approved', 'rejected', 'needs_revision'],
    default: 'pending'
  },
  reviewNotes: String,
  reviewedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  reviewedAt: Date,
  
  // Version Control
  version: {
    type: Number,
    default: 1
  },
  parentQuestion: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Question'
  }

}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Virtual for success rate
questionSchema.virtual('successRate').get(function() {
  if (this.usageStats.totalAttempts === 0) return 0;
  return (this.usageStats.correctAttempts / this.usageStats.totalAttempts * 100).toFixed(2);
});

// Virtual for difficulty score (based on success rate)
questionSchema.virtual('difficultyScore').get(function() {
  const successRate = this.successRate;
  if (successRate >= 80) return 'easy';
  if (successRate >= 50) return 'medium';
  return 'hard';
});

// Indexes for better query performance
questionSchema.index({ subject: 1, chapter: 1, class: 1 });
questionSchema.index({ type: 1, difficulty: 1 });
questionSchema.index({ createdBy: 1 });
questionSchema.index({ tags: 1 });
questionSchema.index({ isActive: 1, isPublic: 1 });
questionSchema.index({ reviewStatus: 1 });

// Text search index
questionSchema.index({
  'question.text': 'text',
  'tags': 'text',
  'keywords': 'text',
  'subject': 'text',
  'chapter': 'text'
});

// Pre-save middleware for validation
questionSchema.pre('save', function(next) {
  // Ensure MCQ has exactly one correct answer
  if (this.type === 'mcq') {
    const correctOptions = this.options.filter(option => option.isCorrect);
    if (correctOptions.length !== 1) {
      return next(new Error('MCQ must have exactly one correct answer'));
    }
    
    // Ensure at least 2 options for MCQ
    if (this.options.length < 2) {
      return next(new Error('MCQ must have at least 2 options'));
    }
  }
  
  next();
});

// Static method to get questions by criteria
questionSchema.statics.getQuestionsByCriteria = function(criteria) {
  const { subject, chapter, class: classNum, difficulty, type, limit = 30 } = criteria;
  
  const query = { isActive: true };
  
  if (subject) query.subject = subject;
  if (chapter) query.chapter = chapter;
  if (classNum) query.class = classNum;
  if (difficulty) query.difficulty = difficulty;
  if (type) query.type = type;
  
  return this.find(query)
    .populate('createdBy', 'name teacherInfo.rating')
    .limit(parseInt(limit))
    .sort({ createdAt: -1 });
};

// Static method to get random questions
questionSchema.statics.getRandomQuestions = function(criteria, count = 30) {
  const { subject, chapter, class: classNum, difficulty } = criteria;
  
  const matchQuery = { isActive: true };
  if (subject) matchQuery.subject = subject;
  if (chapter) matchQuery.chapter = chapter;
  if (classNum) matchQuery.class = classNum;
  if (difficulty) matchQuery.difficulty = difficulty;
  
  return this.aggregate([
    { $match: matchQuery },
    { $sample: { size: count } },
    {
      $lookup: {
        from: 'users',
        localField: 'createdBy',
        foreignField: '_id',
        as: 'creator',
        pipeline: [{ $project: { name: 1, 'teacherInfo.rating': 1 } }]
      }
    }
  ]);
};

// Instance method to update usage statistics
questionSchema.methods.updateUsageStats = function(isCorrect, timeSpent) {
  this.usageStats.totalAttempts += 1;
  if (isCorrect) {
    this.usageStats.correctAttempts += 1;
  }
  
  // Update average time
  const currentAvg = this.usageStats.averageTime || 0;
  const newAvg = ((currentAvg * (this.usageStats.totalAttempts - 1)) + timeSpent) / this.usageStats.totalAttempts;
  this.usageStats.averageTime = Math.round(newAvg);
  
  return this.save();
};

module.exports = mongoose.model('Question', questionSchema);
